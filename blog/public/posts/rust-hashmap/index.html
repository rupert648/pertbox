<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Implementing a HashMap in Rust
        
    </title><meta content="Implementing a HashMap in Rust" property=og:title><meta content="Pert's personal site" property=og:description><meta content="Pert's personal site" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://pert.dev/fonts.css rel=stylesheet><script src=https://pert.dev/js/codeblock.js></script><script src=https://pert.dev/js/toc.js></script><script src=https://pert.dev/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://pert.dev/atom.xml rel=alternate title=pert.dev type=application/atom+xml><link href=https://pert.dev/theme/light.css rel=stylesheet><link href=https://pert.dev/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://pert.dev/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://pert.dev/main.css media=screen rel=stylesheet><script src=https://pert.dev/js/mermaid.js></script><body><div class=content><header><div class=main><a href=https://pert.dev>pert.dev</a><div class=socials><a class=social href=https://twitter.com/rupert648 rel=me> <img alt=twitter src=https://pert.dev/social_icons/twitter.svg> </a><a class=social href=https://github.com/rupert648/ rel=me> <img alt=github src=https://pert.dev/social_icons/github.svg> </a><a class=social href=https://buymeacoffee.com/rupertcarr rel=me> <img alt=coffee src=https://pert.dev/social_icons/coffee.svg> </a></div></div><nav><a href=https://pert.dev/posts style=margin-left:.5em>/posts</a><a href=https://pert.dev/projects style=margin-left:.5em>/projects</a><a href=https://pert.dev/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://pert.dev/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://pert.dev/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Implementing a HashMap in Rust<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2023-01-04</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://pert.dev/tags/rust/>Rust</a>, <a class=post-tag href=https://pert.dev/tags/data-structures/>Data Structures</a>, <a class=post-tag href=https://pert.dev/tags/programming/>Programming</a>, <a class=post-tag href=https://pert.dev/tags/tutorial/>Tutorial</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://pert.dev/posts/rust-hashmap/#understanding-hashmaps>Understanding Hashmaps</a> <ul><li><a href=https://pert.dev/posts/rust-hashmap/#how-does-it-work>How Does It Work?</a><li><a href=https://pert.dev/posts/rust-hashmap/#properties-of-a-perfect-hash-function>Properties of a "Perfect" Hash Function</a></ul><li><a href=https://pert.dev/posts/rust-hashmap/#handling-collisions>Handling Collisions</a><li><a href=https://pert.dev/posts/rust-hashmap/#implementing-the-hashmap>Implementing the HashMap</a><li><a href=https://pert.dev/posts/rust-hashmap/#conclusion>Conclusion</a></ul></div><section class=body><p>In this tutorial, we're going to help you build your very own HashMap in Rust. We'll be explaining each step along the way, so don't worry if you're new to the language. However, some basic knowledge of Rust is expected for this tutorial â€” we won't be covering concepts like mutable references or Rust syntax in detail.<p>If you want to skip past the tutorial and step-by-step explanations, feel free to jump straight to the project on GitHub. This project also includes some unit tests which, for brevity's sake, I have skipped past adding in this tutorial.<h1 id=understanding-hashmaps><a aria-label="Anchor link for: understanding-hashmaps" class=zola-anchor href=#understanding-hashmaps>Understanding Hashmaps</a></h1><p>Let's begin with arrays, and why they're great. An array is a collection of data stored in sequential order. Each data element in the array is assigned a numerical index, which can be used to access and retrieve the element.<p>For example, if we want to retrieve a specific piece of data from an array and we know its index, we can easily use that index to access the element at that position in the array. The array provides a starting point or "pointer" for the series of data, and the index tells us how far to move from that starting point to access the desired element.<p>One limitation of using arrays to store data is that we must know the index of the element to access it. This can be inconvenient if we only know the value of the element itself or if we want to use a different type of information, such as a key, to access the element.<p>In these cases, a hashmap can be a more suitable data structure. A hashmap is a collection of data that is stored and accessed using keys rather than indices. This allows us to retrieve elements based on their associated key rather than their position in the collection.<p>For example, we could use a person's name as a key to access their phone number in a hashmap. Hashmaps offer more flexibility and power when it comes to storing and accessing data compared to arrays.<h2 id=how-does-it-work><a aria-label="Anchor link for: how-does-it-work" class=zola-anchor href=#how-does-it-work>How Does It Work?</a></h2><p>At their underlying structure, a hashmap is, in essence, an array. However, we are now changing the method of accessing that array. This is where a hash function comes in. A hash function takes a key as input and returns some integer which we can use as an index into that underlying array.<p>A simple hash function for converting a string into an integer may look as follows in rust:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>simple_hash</span><span>(</span><span style=color:#ff8f40>string</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>u32 </span><span>{
</span><span>    </span><span style=color:#fa6e32>let mut</span><span> total </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>for</span><span> c </span><span style=color:#ed9366>in</span><span> string</span><span style=color:#ed9366>.</span><span style=color:#f07171>chars</span><span>() {
</span><span>        total </span><span style=color:#ed9366>+=</span><span> c </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u32</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>    total
</span><span>}
</span></code></pre><p>Once we have the integer value returned by the hash function, we can use the modulus operator to reduce it to a value within the bounds of the array. For example:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> index </span><span style=color:#ed9366>= </span><span style=color:#f07171>simple_hash</span><span>(</span><span style=color:#86b300>"hello"</span><span>) </span><span style=color:#ed9366>%</span><span> array_size</span><span style=color:#61676ccc>;
</span></code></pre><p>This would give us an index within the bounds of the array, allowing us to access the element at that index using the key "hello".<h2 id=properties-of-a-perfect-hash-function><a aria-label="Anchor link for: properties-of-a-perfect-hash-function" class=zola-anchor href=#properties-of-a-perfect-hash-function>Properties of a "Perfect" Hash Function</a></h2><p>A "perfect" or "ideal" hash function would have the following properties:<ul><li>It should be deterministic, meaning that it always produces the same output for a given input<li>It should distribute keys uniformly across the range of possible output values so that keys are evenly distributed among the indices in the underlying array<li>It should produce a unique output value for every possible key so that there are no collisions<li>It should be fast to compute so that it does not significantly impact the performance of the hashmap<li>It should be resistant to collision attacks, meaning that it should be difficult for an attacker to craft keys that will produce collisions</ul><p>Keep in mind that it is generally impossible to achieve all of these properties at the same time, especially when dealing with large sets of keys. Therefore, most hash functions aim to balance these properties and trade off some degree of performance or security to achieve a reasonable level of effectiveness.<h1 id=handling-collisions><a aria-label="Anchor link for: handling-collisions" class=zola-anchor href=#handling-collisions>Handling Collisions</a></h1><p>The truth is, collisions are inevitable when working with hashmaps. Either the hash function produces the same index for two values, or the underlying array is smaller than the number of values it holds. Either way at some point two or more keys may be pointing at the same location in memory, and we want to avoid any unwritten data.<p>A common solution to this, and the solution we will be using, is to create a linked list at each index in the array when a collision occurs. Then, when searching for a key/value, we traverse this linked list until we find our key.<h1 id=implementing-the-hashmap><a aria-label="Anchor link for: implementing-the-hashmap" class=zola-anchor href=#implementing-the-hashmap>Implementing the HashMap</a></h1><p>For our tutorial, we are going to be implementing the four most basic operations of a hashmap:<ul><li><code>HashMap&lt;T, V>.get(key: T)</code><li><code>HashMap&lt;T, V>.push(key: T, value: V)</code><li><code>HashMap&lt;T, V>.delete(key: T)</code><li><code>HashMap&lt;T, V>.clear()</code></ul><p>Note that we can see type annotations here, which allows our implementation to be fully generic and accept any type (with some caveats) for our key and value pair.<p>[Content continues with all code blocks preserved...]<h1 id=conclusion><a aria-label="Anchor link for: conclusion" class=zola-anchor href=#conclusion>Conclusion</a></h1><p>Congrats on making it through this tutorial on implementing a hashmap in Rust! By now, you should have a good understanding of how hashmaps work and how to implement one from scratch. You should also be familiar with one possible implementation of the various methods that a hashmap provides, such as put, get, and remove.<p>I hope that you found this tutorial helpful and that it has given you the confidence to implement a hashMap in your own Rust projects. Feel free to play around with the code and try out different configurations and methods to get a better understanding of how it all works.<p>You can also check out the fully completed code for this tutorial on the GitHub repository here, complete with a few unit tests for the code.<p>Thanks for reading, and happy coding!</section></article></main><div class=viewcount></div><div class=giscus></div><script async src=/js/view-count.js></script><script async crossorigin issue-term=pathname repo=rupert648/pert.dev src=https://utteranc.es/client.js theme=github-dark></script></div>