<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         My growing lack of trust in typescript code
        
    </title><meta content="My growing lack of trust in typescript code" property=og:title><meta content="Pert's personal site" property=og:description><meta content="Pert's personal site" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://pert.dev/fonts.css rel=stylesheet><script src=https://pert.dev/js/codeblock.js></script><script src=https://pert.dev/js/toc.js></script><script src=https://pert.dev/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://pert.dev/atom.xml rel=alternate title=pert.dev type=application/atom+xml><link href=https://pert.dev/theme/light.css rel=stylesheet><link href=https://pert.dev/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://pert.dev/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://pert.dev/main.css media=screen rel=stylesheet><script src=https://pert.dev/js/mermaid.js></script><body><div class=content><header><div class=main><a href=https://pert.dev>pert.dev</a><div class=socials><a class=social href=https://twitter.com/rupert648 rel=me> <img alt=twitter src=https://pert.dev/social_icons/twitter.svg> </a><a class=social href=https://github.com/rupert648/ rel=me> <img alt=github src=https://pert.dev/social_icons/github.svg> </a><a class=social href=https://buymeacoffee.com/rupertcarr rel=me> <img alt=coffee src=https://pert.dev/social_icons/coffee.svg> </a></div></div><nav><a href=https://pert.dev/posts style=margin-left:.5em>/posts</a><a href=https://pert.dev/projects style=margin-left:.5em>/projects</a><a href=https://pert.dev/tags style=margin-left:.5em>/tags</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://pert.dev/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://pert.dev/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>My growing lack of trust in typescript code<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-02-17</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://pert.dev/tags/software/>Software</a>, <a class=post-tag href=https://pert.dev/tags/typescript/>Typescript</a>, <a class=post-tag href=https://pert.dev/tags/javascript/>Javascript</a>, <a class=post-tag href=https://pert.dev/tags/rust/>Rust</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://pert.dev/posts/ts-growing-lack-of-trust/#introduction>Introduction</a><li><a href=https://pert.dev/posts/ts-growing-lack-of-trust/#types>Types</a><li><a href=https://pert.dev/posts/ts-growing-lack-of-trust/#error-handling>Error Handling</a> <ul><li><a href=https://pert.dev/posts/ts-growing-lack-of-trust/#conclusion>Conclusion</a></ul></ul></div><section class=body><h2 id=introduction><a aria-label="Anchor link for: introduction" class=zola-anchor href=#introduction>Introduction</a></h2><p>I have worked both on large scale high traffic Typescript and Rust systems, and most recently a weird mutation of the two through <a href=https://napi.rs/>napi-rs</a>. Whilst there are plenty more experienced than I, this most recent adventure has given me a unique point of reference on the differences, pain points and benefits of each.<p>Firstly I want to preface by saying I <em>love</em> typescript, I try and stay away from the types vs untyped debate on various social medias for my own sanity, but once you reach a project of an even moderate size, I will admit I really struggle to see how the untyped side of the debate isn't massively overshadowed by the benefits that type safety brings. Furthermore, none of the ideas I am presenting here are novel, in fact they have been talked about in length, I just wanted an outlet for my own pain.<p>So what is this article all about? If typescript is so great and so much better than Javascript, why is my distrust in typescript code, day to day, still growing? This article, I guess, is now just a further extension of these type philosophies and as I hope to demonstrate in this article, genuine practicalities I've found of extending this type safety one step further beyond typescript, and how doing to so elevates the level of reliability you can have in your software.<h2 id=types><a aria-label="Anchor link for: types" class=zola-anchor href=#types>Types</a></h2><p>There are a million and one articles out on the internet over why types are beneficial, and I don't expect to convince you in this one article, I just hope to show you some examples of why even Typescript has its limitations over a more strongly run-time typed language; in this case Rust.<div class=note-container><div class=note-header><div class=note-center></div></div><div class=note-content><p>Typescript's safety is only as strong as the programmers motivation to use it.</div></div><p>As I'm sure most readers of this article are aware, Typescript is a <em>compile time</em> typed language. Type checks are only enforced at the time of compilation, and to ensure types are satisfied at runtime runtime checks must be introduced. Entire libraries are dedicated to this functionality such as <a href=https://zod.dev/>zod.dev</a>. This leads to my and many people's first gripe; Typescripts safety is only as strong as the programmers motivation to use it.<p>The most obvious example of this is the <code>any</code> type; cant be arsed to fill out that annoying type definition? Stick an <code>any</code> in there and you're good to go. There. You've just made typescript obsolete, albeit in a very transparent way. This is easily rectified in any sensible project; just disable any. But its also still surprisingly easy to lie to the compiler, heres an example;<pre class=language-ts data-lang=ts style=color:#61676c;background-color:#fafafa><code class=language-ts data-lang=ts><span style=color:#fa6e32>interface </span><span style=color:#399ee6>User </span><span>{
</span><span>  name</span><span style=color:#ed9366>: </span><span style=color:#55b4d4;font-style:italic>string</span><span style=color:#61676ccc>;
</span><span>  age</span><span style=color:#ed9366>: </span><span style=color:#55b4d4;font-style:italic>number</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// This is clearly wrong, but TypeScript accepts it
</span><span style=color:#fa6e32>const </span><span>fakeUser </span><span style=color:#ed9366>= </span><span>{} </span><span style=color:#fa6e32>as </span><span style=color:#399ee6>User</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// No error, even though properties are missing
</span><span>
</span><span style=color:#55b4d4;font-style:italic>console</span><span style=color:#ed9366>.</span><span style=color:#f07171>log</span><span>(fakeUser</span><span style=color:#ed9366>.</span><span>name</span><span style=color:#ed9366>.</span><span style=color:#f07171>toUpperCase</span><span>())</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// TypeError: Cannot read properties of undefined
</span></code></pre><p>This kind of pattern is actually extremely common. The best and most frequent example I have seen is when reading some external IO source, such as the response from a service. Each time I encounter this pattern in production code, my trust erodes a little more. What started as a strongly-typed promise becomes a game of 'hope the runtime data matches our types'.<p>I mentioned above our mutant typescript-rust project I am currently working on, where we are slowly migrating the typescript code to rust, and one of the most common forms of bugs we face is when translating the typescript objects to rust structs, our typescript types for services responses were wrong!<p>Take the above example<pre class=language-ts data-lang=ts style=color:#61676c;background-color:#fafafa><code class=language-ts data-lang=ts><span style=color:#fa6e32>type </span><span style=color:#399ee6>User </span><span style=color:#ed9366>= </span><span>{
</span><span>  name</span><span style=color:#ed9366>: </span><span style=color:#55b4d4;font-style:italic>string</span><span style=color:#61676ccc>;
</span><span>  age</span><span style=color:#ed9366>: </span><span style=color:#55b4d4;font-style:italic>number</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>Converting this to rust would give the following struct<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>derive</span><span>(Deserialize</span><span style=color:#61676ccc>,</span><span> Serialize)]
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>User </span><span>{
</span><span>  name</span><span style=color:#61676ccc>:</span><span> String;
</span><span>  age</span><span style=color:#61676ccc>:</span><span> String;
</span><span>}
</span></code></pre><p>Now lets look at the typescript code to read this response from a service:<pre class=language-ts data-lang=ts style=color:#61676c;background-color:#fafafa><code class=language-ts data-lang=ts><span style=color:#fa6e32>async function </span><span style=color:#f29718>fetchUser</span><span>()</span><span style=color:#ed9366>: </span><span style=color:#399ee6>Promise</span><span>&lt;</span><span style=color:#399ee6>User</span><span>> {
</span><span>  </span><span style=color:#fa6e32>const </span><span>response </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>await </span><span style=color:#f29718>fetch</span><span>(</span><span style=color:#86b300>'/api/user'</span><span>)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>const </span><span>data </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>await </span><span>response</span><span style=color:#ed9366>.</span><span style=color:#f29718>json</span><span>()</span><span style=color:#61676ccc>;
</span><span>  
</span><span>  </span><span style=color:#fa6e32>return </span><span>data </span><span style=color:#fa6e32>as </span><span style=color:#399ee6>User</span><span style=color:#61676ccc>;  
</span><span>}
</span></code></pre><p>And the rust code:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_user</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&lt;User, </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&lt;dyn Error>> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> response </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(</span><span style=color:#86b300>"/api/user"</span><span>)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let</span><span> user</span><span style=color:#61676ccc>:</span><span> User </span><span style=color:#ed9366>=</span><span> response</span><span style=color:#ed9366>.</span><span style=color:#f07171>json</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(user)
</span><span>}
</span></code></pre><p>Now lets say we get such a response from our api service<pre class=language-json data-lang=json style=color:#61676c;background-color:#fafafa><code class=language-json data-lang=json><span>{
</span><span>  </span><span style=color:#f51818>name</span><span style=color:#61676ccc>: </span><span style=color:#86b300>"Rupert"
</span><span>}
</span></code></pre><p>So now we've actually moved to rust, we noticed that our typescript code was <em>wrong</em>. The rust code would blowup immediately at our <code>response.json()</code> line, whilst the typescript code would trundle happily on. Whilst an error is never fun, this is a good thing! We have <em>failed fast and early</em>. From this translation we've immediately caught a bug, which if left to fester in the typescript code as an unknown <code>undefined</code> could have hurt us in more subtle, but painful ways. This is where my trust really started to crack. We had months of production TypeScript code running with incorrect types, silently accepting malformed data. The compiler happily verified our lies, while Rust refused to participate in our self-deception.<h2 id=error-handling><a aria-label="Anchor link for: error-handling" class=zola-anchor href=#error-handling>Error Handling</a></h2><div class=note-container><div class=note-header><div class=note-center></div></div><div class=note-content><p>Try catch is like throwing a glass of water into a crowded room, where everyone is blindfolded, and expecting the glass to be caught without spilling a drop.</div></div><p>The next thing I want to talk about is error handling. Notice in the rust code how we had to <strong>explicitly</strong> handle all the possible errors.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_user</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&lt;User, </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&lt;dyn Error>> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> response </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(</span><span style=color:#86b300>"/api/user"</span><span>)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let</span><span> user</span><span style=color:#61676ccc>:</span><span> User </span><span style=color:#ed9366>=</span><span> response</span><span style=color:#ed9366>.</span><span style=color:#f07171>json</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"User API response didn't match expected shape."</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(user)
</span><span>}
</span></code></pre><ul><li>our function returns <code>Result</code><li>our use of reqwest uses <code>?</code> to subtly the error case of <code>request::get</code><li>our use of reqwest uses <code>?</code> to subtly the error case of <code>response.json()</code></ul><p>This comes on to my next big gripe - not just with typescript but far too many other languages - try catch error handling. God, after writing production rust code as my main output for a number of months now, I <em><strong>HATE</strong></em> try catch with a burning passion. Try catch is like throwing a glass of water into a crowded room, where everyone is blindfolded, and expecting the glass to be caught without spilling a drop.<p>When calling a function in TypeScript, you literally have no idea whether that function will return an error or not! It's so crazy after getting used to constructs like Result in Rust or _val, err in Go. In TypeScript, you're basically working blind - any function could throw at any time, for any reason, and the type system gives you zero help. You can't tell by looking at a function signature whether it might explode in your face. The worst part is that this invisibility of errors means they often go unhandled, bubbling up through your application until they crash something important. Meanwhile, Rust and Go and a number of other languages which aren't java or javascript force you to acknowledge and handle errors explicitly - the compiler won't let you ignore them. It's like the difference between walking through a minefield with a metal detector versus walking through blindfolded and hoping for the best. Or even better, in languages such as Rust there are literal signs marking exactly where a bomb lies. As so many others have emphasised in the past, try-catch feels like a trust exercise gone wrong. When I call a TypeScript function, I have to trust that someone, somewhere, has handled all possible errors, or blindly throw on my own error handling logic just in case. After seeing too many unhandled promise rejections in production, that trust is hard to maintain.<div class=note-container><div class=note-header><div class=note-center></div></div><div class=note-content><p>Typescript types are an exercise in convincing, rust types are an exercise of proof.</div></div><p>Sometimes, I want everything to blowup, because it means some error in my logic. But the key difference is that in rust <em>I have explicit control over this</em>. Lets return one last time to our user example. Lets say in this case we own the user api, and we are handling the response from another microservice we control. In this case, if our struct is incorrect, it makes sense to completely blow up, as this indicates some error with our own implementation either on this service or the user api service which we own. This is distinct from an input from an uncontrolled source such as user input.<p>In rust, we can make this super easy.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_user</span><span>() </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&lt;User, </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&lt;dyn Error>> {
</span><span>    </span><span style=color:#fa6e32>let</span><span> response </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(</span><span style=color:#86b300>"/api/user"</span><span>)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>?</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>let</span><span> user</span><span style=color:#61676ccc>:</span><span> User </span><span style=color:#ed9366>=</span><span> response</span><span style=color:#ed9366>.</span><span style=color:#f07171>json</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>expect</span><span>(</span><span style=color:#86b300>"User API response didn't match expected shape."</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(user)
</span><span>}
</span></code></pre><p>Of course this is possible in TS as well, but remember what I said about effort in TS? We have to go through and add the blowup logic ourselves, using some validation library such as zod or other, or go and throw down a bunch of the ugly and dreaded <code>if (user.name && typeof user.name === 'string')...</code>. My key point is this; Typescript types are an exercise in convincing, rust types are an exercise of proof.<h3 id=conclusion><a aria-label="Anchor link for: conclusion" class=zola-anchor href=#conclusion>Conclusion</a></h3><p>This isn't about TypeScript being bad - it's about understanding its limitations. My trust hasn't eroded because TypeScript failed to deliver on its promises, but because those promises were more modest than we initially assumed. As our systems grow more complex, we need guarantees, not gentle suggestions. We need proof, not trust.<p>Is this article telling you to stop using Typescript and rewrite everything in rust? Of course not! Typescript is and will likely be for a long time my go to language for hobby projects and spinning up prototypes quickly, but lets just set reasonable expectations on what we can expect to achieve with only compilation time guarantees.</section></article></main><div class=viewcount></div><div class=giscus></div><script async src=/js/view-count.js></script><script async crossorigin issue-term=pathname repo=rupert648/pert.dev src=https://utteranc.es/client.js theme=github-dark></script></div>